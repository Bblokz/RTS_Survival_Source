You are going to implement the new hotkey feature which will integrate with the user settings to display the correct
hotkey for action items ; UW_ItemActionUI of which the associated actions are IA_ActionButtonN where N is the index of that
action ui item (const int32 IndexActionUIElm)
the same goes for the control groups;  each control group has a UW_ControlGroupImage that now also holds a hotkey;
the numbering of the control group actions goes like IA_ControlGroup1, IA_ControlGroup2 , ... till IA_ControlGroup10 so no zero.
originally the controll group image used their index and used that to display their static hotkey with 	UFUNCTION(BlueprintImplementableEvent)
                                                                                                       	void SetupControlGroupIndex(const int32 GroupIndex);
 you need to refactor this to use the new hotkey provider system as well; where index 0 for a control group image
 means action IA_ControlGroup1 and index 9 means IA_ControlGroup10.

 Add a single “Hotkey Provider” (subsystem) that can answer: “Key for slot N?”

Give UW_ItemActionUI zero knowledge of Enhanced Input internals.
Instead:
UW_ItemActionUI::InitActionUIElement(...) stores:
owning controller (or local player reference)
its IndexActionUIElm
reference a subsystem
Immediately (or on the next tick if you prefer), it asks:
Provider → GetDisplayKeyForActionSlot(IndexActionUIElm)
That provider does the actual work:
Convert slot index → UInputAction* (IA_ActionButton[n])
Query current mapping(s)
Pick the “primary” key to display (keyboard vs gamepad rules)
Return a display string/text suitable for your UW_HotKey RichTextBlock
Result: each action button’s M_ActionItemHotKey just receives “F” / “1” / “Mouse4” / “RB” etc.


make sure that as soon as the player updates the keybindings through the settings the subsystem is notified of this and has delegates
for both action ui buttons and control group buttons so they can be updated with their new IA_ ... hotkey!