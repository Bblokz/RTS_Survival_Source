Parts of turn for player:

*** chapters ***
Chapter 1: at the edge of the fow show the russian wall, behind that are the important cities.

Chapter2: attack waves start from the wall.

Chapter3: break through the wall
*********************************************

*** Large world map objects, points of interest.
Visible through the fow ***

-The east wall 🧱 : unlocks chapter.
-water Dam: several points along river; one is chosen. Has a special break the dam mission.
Will destroy 2 map items downstream.

- radixite ground zero ☢️: heavy radiation zones where some vehicles are not available.

- The black forrest🌲: too dense for vehicles to pass. An infantry and light mechanized troups only mission.


Make sure there is a turn counter:
- to keep track of how long events last
- One mission is one turn

Player Profile:
-Gain cards from missions
-Gain cards from winning events
-Gain commander experience from missions

The profile will still be saved in the different file like now, do need new UI for selecting profile cards.

Commander experience:
- unlock more starting units and resources slots
- unlock extra slots on the factories.
Card slots will start with costing one perk
But as the player unlocks more they get more expensive to prevent focussing too much on one type-


--- The Players's Turn ---
Spend perk points gained from commander xp
Spend radixite and blueprints on tech.
Upgrade allied airfield and factories with radixite and construction blueprints
Pick location to start mission:
- location difficulty in percentage, has dialog for enemy strenght estimate.
- increased by nearby airfields, artillery batteries,
And nearby troops.
-provide warning if player chooses a very difficult mission while having a low level.
-on victory: gain bonusses.
-on defeat: area becomes harder. Maybe loose exp too?
Post mission complete: enemy turn.

--- Enemy Turn ---
Show animation of enemy strenght increase on none engaged areas in %
Nearby supply depots or railroads should show an additional % increase animation.
Move convoys
Deploy convoys
Move divisions
Add upgrades to map items

--- Enemy items ---

1. AIrbase : allows for off map aircraft support.
Sizes: normal or large 
Normal: -lagg yak sturmovic
Large: Normal planes + bombers

2. Supply depo -> Rail hub: provides resources to nearby bases: meaning extra strenght increase in enemy's turn.

3. Factory: created armored divisions overtime.
-Normal: light armored divisions
Medium armored divisions

-large: heavy armored divisions only

4 research fascility: enemy bases gain higher tier units quicker

5 fortified checkpoint.

6. Barracks: creates infantry divisions overtime 

--- neutral items ---
Radixite crater: high radiation zones,
Lots of radixite resources.

--- Dynamic event items ---
1. Russian convoy:
Provides starting resource cards or blueprint cards as bonusses if destroyed.

Moves through enemy held regions for x turns. If not destroyed within x turns it will start a new base

--------- General work flow for adjusting the world map --------------------
need some spline based overlay that shows what the area of the soviet influence is.
AAnchorPoints; General world map point; the campaign will be generated by promoting these points to 
either mission points, enemy map items, player map items. or neutral items.

sight of items: neutral items should always be visible.
other items: if not a player item; then only visible if 2 away from a player item in the graph.

campaign generation depends on campaignGenerationSettings which will contain the difficulty percentage.
and a seed.
and later other settings.
the campaign generation needs to be an editor callable function so the designer can see how a generation will play out.

first step to get working: determine connections between the map anchorpoints.
how missions will be placed: 
we have the list of EMapMission 


you are going to start working on the world campagin logic.

in the RTS_Survival folder add a new folder called WorldCampaign.
in there add a folder called WorldMapObjects
In there add a folder called AnchorPoint
and a folder Connection
in both respectively you will create the new aactor derived classes AAnchorPoint and AConnection.
under WorldCampaign also add a folder called CampaignGeneration in there add a folder called GeneratorWorldCampaign. where the new actor derived AGeneratorWorldCampaign will be placed.
You can assume that on the campaign map i will have placed this actor on the map already.

Give every anchor point a stable key (FGuid on the actor, or a cooked-time ID, or quantized world position
Sort your nodes by that key.
For each node, sort its neighbors by that key. 

I want you to implement a struct called FConnectionGenerationRules which is bp friendly and has every field as edit anywhere so i can edit it in the editor on the AGeneratorWorldCampaign  instance. make sure to use a good category too.
It will have the constrains for generating connections between aanchor points.
Important: make sure to always clear any AConnections before generating again. the GenerateConnections function must be editor executable so i can easily test it in the editor with different parameters (the edit anywhere ones!) Also make sure there is new bool under DeveloperSettings Debugging namespace for compile debug symbols for CampaignConnectionGeneration and if const expr true call functions on the aanchor and connection points that will show me how the algorithm is progressing and what connections are made also draw debug lines for connections and use different colors depending on whether it is a regular connection, one that had to go further because we did not hit min connectiosn or one that became a 3 way -> in that case draw the 3rd connection line on the other line to wards the 3rd aanchor point. see the following:
here are the constraints:
1. int32 MinConnections
2 int32 MaxConnections
3 MaxPrefferedDistance.
given that we have the array of anchor points on the map we want for each to give them an array of pointers to AConnection actors that will be placed between the actors to connect. we only consider XY no Z for estabilishing the connections.
For each actor we want to generate an amount of preffered connections between the min max using the seed.
i want this to be done by searching for the closest other AAnchor points with an important caviat; check if a potential new connection DOES NOT intersect a connection that is already established (again only in XY space) this is not allowed; look for another connection if it does.
After we have found connections that satesfy this see if we have at least min connections for this AAnchor point if not? then disregard the distance rule and look for aanchor points further (again no intersects) and if we then still do not have enough to have at least minconnections then add the aanchor to the closest AConnection that is not already a connection to this point; making it a special 3 way connection do this until we have min connections.

How i want to do this:
Core idea
Build an undirected straight-line planar graph incrementally:
Each anchor gets a DesiredDegree = random in [MinConnections, MaxConnections] using the seed.

Iterate anchors in a seeded shuffled order, and greedily connect to nearest candidates first (within MaxPreferredDistance), only if:

the edge doesn’t already exist,

both endpoints won’t exceed MaxConnections,

the segment doesn’t intersect any existing segment in XY (excluding shared endpoints).

If an anchor can’t reach MinConnections:

Phase B: ignore distance and keep searching further points (still no intersections).

Phase C: if still short, attach it to the closest existing connection segment via a junction (3-way), again ensuring the new branch doesn’t intersect others.

Make sure all of the debug code is in separate helper privates and never called if the constexpr fails. make sure the code is clean and according to the standard.

----------- PSEUDO CODE --------------
First make sure all UI Objects are created correctly to make sure it is clear what data needs to be handled in the backend

WorldPlayerController : CardPlayerController.

Post init:
-load world UI from class (hardref)
-PlayerProfileLoader async load profile.
-init player commander levels and perks.
-load map setup:
{


enum class EMapItemType : uint8
{
None,
Empty,
Mission
EnemyItem,
PlayerItem,
NeutralItem
}

enum class EMapMission: uint8
{
None,
HetzerMission,
TigerPantherRange,
JagdpantherMission,
SturmtigerDam,
}

enum class EMapEnemyItem : uint8
{
None,
Factory,
Airfield,
Barracks,
SupplyDepo,
ResearchFacility,
FortifiedCheckpoint
}

enum class EMapPlayerItem
{
None,
Factory,
Airfield,
Barracks
}

You will now continue working on the world map generation. 
Note that you first will have to define varius placement rules structs and new enums in the enum folder before starting on the generation functions which also need to be editor callable.
right now focus only only setting up all of the structs and enums needed and integrating them with the AGeneratorWorldCampaign actor.

The starting point of the entire campaign generation is the player's HQ. This one you will place first.
also have an enum for the generator itself that keeps track of the steps; if possible gray out the buttons for steps that are not valid at the moment:
it always needs to be done in a specific order:
-> Create connections
-> Place HQ
-> Place Enemy HQ
-> Place Enemy Objects
-> Place Neutral Objects
-> Place Missions

Make sure to add EnemyHQ to EMapEnemyItem!
we want a campagin generation helper namespace with functions for:

Graph distance (HopsFromHQ): BFS steps along AConnections.
 Best for gameplay progression (rings/tiers).

World distance (XYDistanceFromHQ): FVector2D::Distance.
 Best for “keep stuff visually far/close”.

both of these will ofcourse need to get  the achnor point

also add en enum to the  enums  dir ; in its own dir this enum will be called
// this enum determines how  candidates within the min max  connections bounds are  decided upon;  if not set we just take the first in the options that  satisfies the min max  connections. if PreferMaxConnections we first want to look for the candidates that have connection amounts closer to our max etc.
ETopologySearchStrategy
NotSet,
PreferMax
PreferMin
note that this search strategy will be used for both connection amounts and hops amounts for distance.



Placement rules for items:
again make sure these are all editanywhere and exposed on the  campaign generator with  good categorization 

struct FPlayerHQPlacementRules
-- Array of weak pointers to anchors set by designer.
implementation of rules: pick one depending on the rules below. This is the start point for the entire campaign generation.
--Anchor degree constraints: avoid dead-ends MinAnchorDegreeForHQ (typical 2 or 3)
Start neighborhood size: ensure enough anchors nearby to populate early content MinAnchorsWithinHops (e.g., at least 6 within 2 hops)
Safe ring: no enemies inside a hop radius
SafeZoneMaxHops (e.g., 1–2) // technically these will be used for the enemy placement later as the HQ is first placed when there are no enemy items yet.

struct FEnemyHQPlacementRules
-- Array of weak pointers to anchors set by designer.
-- min and max anchor degree as well as a ETopologySearchStrategy for preference.


add another enum called EMissionTier
which will have  values:
NotSet,
Tier1,
Tier2, Tier3, Tier4

and another enum for  neutral items:
EMapNeutralObjectType
None,
RadixiteField,
RuinedCity,
DenseForrest,

another enum: (make sure to keep the comments too)
UENUM(BlueprintType)
enum class EAdjacencyPolicy : uint8
{
NotSet,
RejectIfMissing,         // mission candidate anchor is invalid unless requirement already satisfied
TryAutoPlaceCompanion,   // if missing, try to place the required object on a connected yet empty anchor or
in case this about a neutral object and having a mission or map object spawned on top of it; try spawn the neutral object on an yet empty
achnchor and place our object on top of that.
};

another struct:

USTRUCT(BlueprintType)
struct FMapObjectAdjacencyRequirement
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Requirement")
	bool bEnabled = false;

	// What must be nearby (one connetion away):
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Requirement", meta=(EditCondition="bEnabled"))
	EMapItemType RequiredItemType = EMapItemType::NeutralItem;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Requirement", meta=(EditCondition="bEnabled"))
    uint8 RawByte_SpecificItemSubtype = 0; // use static cast to set EMapNeutralObjectType, EMapMission, etc.	

// How many of these nearby?
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Requirement", meta=(EditCondition="bEnabled"))
	int32 MinMatchingCount = 1;

	// Define “nearby”: the max connections away
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Adjacency", meta=(EditCondition="bEnabled"))
	int32 MaxHops = 1;

	// What to do if missing:
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Requirement", meta=(EditCondition="bEnabled"))
	EAdjacencyPolicy Policy = EAdjacencyPolicy::RejectIfMissing;
};

we als need a specific enum for enemy item placement:
UENUM(BlueprintType)
enum class EEnemyTopologySearchStrategy : uint8
{
	None,
	PreferLowDegree,     // prefer low degree of connections
	PreferHighDegree,    // prefer high degree of connections
	PreferChokepoints,   // high chokepoint score
	PreferDeadEnds,      // degree 1
	PreferNearMinBound,  // bias toward MinHops
	PreferNearMaxBound,  // bias toward MaxHops
};


before we now go over the super struct containing all rules for the placement of enemy items we first go over a few structs that need
to be defined for all the kinds of enemy placement rules. i want you to define all of these in a enemyplacementrules directory.
fenemyitemtoitemspacingrules
int32 minenemyseparationhops_othertype 
int32 minenemyseparationhops_sametype

fenemyitemtoenemyhqspacingrules
int32 minhopsfromenemyhq
int32 maxhopsfromenemyhq
EEnemyTopologySearchStrategy preference

then we want for per enemy item rules:

USTRUCT(BlueprintType)
struct FEnemyItemPlacementRules
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Rules")
	FEnemyItemToItemSpacingRules ItemSpacing;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Rules")
	FEnemyItemToEnemyHQSpacingRules EnemyHQSpacing;

};
and a 
UENUM(BlueprintType)
enum class EEnemyRuleVariantSelectionMode : uint8
{
	None,
	CycleByPlacementIndex,   // VariantIndex = InstanceIndex % Variants.Num()
};
and a varaint struct to override what changes (see caviat note below)
USTRUCT(BlueprintType)
struct FEnemyItemPlacementVariant
{
	GENERATED_BODY()

	// When false, ignore this variant entirely.
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Variant")
	bool bEnabled = true;

	// If true, use these rules instead of base for this placement.
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Variant")
	bool bOverrideRules = false;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Variant", meta=(EditCondition="bOverrideRules"))
	FEnemyItemPlacementRules OverrideRules;
};


now a very important caviat for the later placement of these enemy objects is the following:
To avoid all enemy items of the same type ending up in the same area (e.g., all Factories at the same hop range from the Enemy HQ), we will support rule variants per enemy item type that are selected deterministically based on how many of that type have already been placed.
During generation, maintain a counter map: PlacedCountByType[EMapEnemyItem]. This counter starts at 0 for each type and is incremented each time an item of that type is successfully placed.
When we are about to place a new enemy item of type T, compute:
InstanceIndex = PlacedCountByType[T] (0-based; first placed is 0, second is 1, etc.)
Each enemy type T has:
one BaseRules block (the default constraints),
and an optional list of RuleVariants (variant rule blocks) plus a variant selection mode.
If variants are enabled for this type, pick which variant to use based on the instance index:
Use a simple cycling strategy: VariantIndex = InstanceIndex modulo VariantCount.
Example with 3 variants: placements 0,3,6 use Variant 0; 1,4,7 use Variant 1; 2,5,8 use Variant 2.
For the selected variant:
If the variant is configured to override rules, use its rules instead of the base rules for this placement.
Otherwise, fall back to BaseRules.
This creates controlled, repeatable variation such as:
every second or third placement shifting the allowed hop range from the Enemy HQ,
or changing topology preference (e.g., one prefers hubs, the next prefers chokepoints),
without introducing randomness that makes tuning unpredictable.

and so we need:
USTRUCT(BlueprintType)
struct FEnemyItemRuleset
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Ruleset")
	FEnemyItemPlacementRules BaseRules;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Ruleset")
	EEnemyRuleVariantSelectionMode VariantMode = EEnemyRuleVariantSelectionMode::None;

	// Example: 3 variants -> placements 0,3,6 use Variants[0], 1,4,7 use [1], 2,5,8 use [2].
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Ruleset", meta=(EditCondition="VariantMode!=EEnemyRuleVariantSelectionMode::None"))
	TArray<FEnemyItemPlacementVariant> Variants;
};

and finally:

USTRUCT(BlueprintType)
struct FEnemyPlacementRules
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Enemy")
	TMap<EMapEnemyItem, FEnemyItemRuleset> RulesByEnemyItem;
}; -> this will be the super struct containing the rules for all types of enemy objects that need to be placed.


for neutral items the rules will be much simpler:

struct FNeutralItemPlacement
only a  min and max hops from HQ,
and a min and max hops from other neutral items.
as well as the ETopologySearchStrategy  for preference.

for mission placements:
 Tier rules (shared defaults)
Create a struct that defines the placement constraints for all missions in a tier:
FMissionTierRules

Distance constraints from HQ (prefer hops, optional XY)
Spacing rules vs other missions (min hops / min XY --> (each of which also with an ETopologySearchStrategy
  )) (should both have a bool as well that turns off the distance constrain (both can be turned off for example or in this way only min hops could be used for a tier etc.
also make sure there are max values for these too which, just as the min, may not be used if the  bool is turned off.

Topology preferences
min and max amount of connections.
and an ETopologySearchStrategy

also give it an optional bNeutralItemNeed by default false.
if true give it a selector of EMapNeutralObjectType ; this mission needs to be placed
on top of one of those neutral items.

in adition give it a FMapObjectAdjacencyRequirement; note that this requirement
if enabled talks about what should be nearby the mission anchorpoint and so is different from the on top of neutral item
requirement .

then on the campaign generator have a super struct called FMissionPlacement
that will first have a tmap from the mission tier enum to the FMissionTierRules.
after that have an ohter tmap from the EMapMission to a new struct called
FPerMissionRules
which will hold the tier enum and an optional override flag (false by default) 

 So it  can either:
use its tier rules, or
override them with mission-specific rules (overwrite specifically for this mission)

UPROPERTY(EditAnywhere) EMissionTier Tier = EMissionTier::None;
UPROPERTY(EditAnywhere) bool bOverrideTierRules = false;
UPROPERTY(EditAnywhere, meta=(EditCondition="bOverrideTierRules"))


Okay now we have all the rule sets. Now we go into the structs for 
determining how many items we will place for each type.

IMPORTANT NOTE 1: we expect there to be more anchor points on the map than needed for the items to be placed. (designer responsibility)
do not adjust the number of items to be placed based on available anchor points.
IMPORTANT NOTE 2: anchor points can never be two things unless it is a neutral item and we have a mission that needs to be placed
on top of it.

Add a dedicated “Count & Difficulty Tuning” struct (EditAnywhere) to the generator.
Difficulty percentage normalization (percentage only, with tunable “log strength”)

Use only DifficultyPercentage (ignore the difficulty enum for scaling counts). DifficultyPercentage ranges from 50..2000 and must be normalized to a stable 0..1 factor without letting the high end explode.
Clamp the input percentage to [DifficultyPercentMin, DifficultyPercentMax] (defaults 50 and 2000, both EditAnywhere).
Compute a baseline log-normalized value (0..1):
LogNormalized = log(ClampedPercent / DifficultyPercentMin) / log(DifficultyPercentMax / DifficultyPercentMin)
This yields 0 at min and 1 at max.
Add an EditAnywhere designer knob that reduces how strongly the log compresses high values.
Conceptually: apply an exponent curve to “uncompress” the top end.
Introduce LogCompressionStrength (EditAnywhere float, default 1.0).
Interpretation:
LogCompressionStrength = 1.0 → pure log curve (strong compression of high values).
LogCompressionStrength < 1.0 → weaker compression (high difficulty stays more impactful).
LogCompressionStrength > 1.0 → stronger compression (high difficulty gets damped even more).
Final difficulty factor:
DifficultyFactor01 = pow(LogNormalized, LogCompressionStrength)
Use DifficultyFactor01 everywhere you previously used “combined difficulty”: it is your single 0..1 driver for count multipliers.

This gives you:
stable scaling across 50..2000,
and a single designer knob to decide whether 2000% should feel “wildly more” (strength < 1) or “still controlled” (strength > 1).
New struct: per-difficulty-enum extra item overrides (enemy + neutral)
Even though the enum no longer affects the base scaling, you still want the enum to provide explicit overrides: “on Brutal add +2 checkpoints and +1 RadixiteField”, etc.
Define a designer-facing struct that maps difficulty enum → extras:
FDifficultyEnumItemOverrides
A per-difficulty entry contains:
ExtraEnemyItemsByType: TMap<EnemyItemEnum, int32>
ExtraNeutralItemsByType: TMap<NeutralTypeEnum, int32>
FDifficultyEnumOverridesTable
Contains one entry per ERTSGameDifficulty (EditAnywhere):
NewToRTS entry
Normal entry
Hard entry
Brutal entry
Ironman entry

Make sure that this same struct for difficulty, also contains the seed.

 we also need a Placement failure policy enum
once globally for the generator in this struct,
optionally overridden per step (Enemy objects might be more strict than neutrals),
Meaning of each policy:
NotSet: use a sensible default (usually BreakDistanceRules_ThenBackTrack).
InstantBackTrack: do NOT relax constraints; if placement fails, undo recent placements and try different candidates immediately.
BreakDistanceRules_ThenBackTrack: if placement fails, progressively relax the “soft” constraints (distance bands, spacing bands, topology preferences), and only if that still fails, backtrack previous placements.


implement all of the new structs and enums and integrate them into the AGeneratorWorldCampaign actor as EditAnywhere properties with good categorization.




